第一范式:字段不可再分，数据表中的每一列都是不可再分的最小单元，确保每一列的原子性。
第二范式：在第一范式的基础之上，属性完全依赖主键，只存储同一类型的数据
第三范式:在第二范式的基础之上，不储存冗余的数据，只储存其他表的主键和唯一键 ( 除主键以外其他列都不传递依赖于主键列)

mysql的数据类型：char和varchar的区别：定长和不定长；char读取的效率高；存储容量。

mysql的索引优化：1.在创建索引的时候采用覆盖索引（减少回表的次数），覆盖索引支持索引下推的一个过程（在查询的时候把覆盖索引的字段进一步筛选，减少回表次数）
                                explain可以检测是否使用索引
                           2.在保证唯一性的情况下可以使用普通索引，因为普通索引可以用到Change Buffer，Change Buffer可以把一些写操作缓存下来，我们在读的时候进行merge操作，
                             这样就可以提高一个写入的速度。

如果索引没有走怎么考虑：1.是不是sql写的有问题（对索引字段使用了一些函数操作）或者在表连接的时候两个表的字符编码不一样，
                                       2.是不是我们的索引统计信息有问题（索引统计信息并不是一个准确值，它是随机取样的一个过程），可以去analyze table重新统计索引信息。

explain分析出来的索引不一定是最优的，在回表的时候可能会涉及到回表操作和排序操作。

索引建的不好导致索引走的很差怎么解决：1，使用force index  ，强制走一个索引
                                                             2.考虑使用覆盖索引加最左原则把不好的索引删掉。

索引的数据结构：
hash（不适合范围查找），二叉树（会造成树往一边走的状况），平衡二叉树（树高太高），
B树（不支持范围查找，如果data存储的是行记录，行的大小随着列数的增大而增大，所占空间就会变大，导致树的增高，增加磁盘的IO次数），
B+树（非叶子节点只存储主键索引，叶子节点存储数据，每个非叶子节点存储的索引值要更多，这也降低了树的高度，支持范围查找）

MyIsam
主要是非聚簇索引
myIsam的数据文件（MYD）和索引文件（MYI）分开存储
叶子节点存储的是索引值还有数据的地址值
MYISAM的主键索引和辅助索引区别：索引结构是一样的，主键索引的键唯一，辅助索引的键可以重复。
在大量的数据要插入的时候适合使用。

InnoDB
是聚簇索引
InnoDB支持行级锁，支持数据库事务。，但是没有存储表的行数，在使用count（*）函数的时候需要扫描全表
每一个InnoDb都有一个聚簇索引。索引文件和数据文件都存储在同一个文件当中（idb）
InnoDb的主键索引的叶子节点会存储索引值和行数据。辅助索引叶子节点会存储索引值，需要回表操作去主键索引当中查询行数据。

sql优化：使用联合索引（覆盖索引），给多个值创建组合键，避免辅助索引中的回表操作。

1.redis的5种数据类型：
string 字符串（可以为整形、浮点型和字符串，统称为元素）
list 列表（实现队列,元素不唯一，先入先出原则）
set 集合（各不相同的元素）
hash hash散列值（hash的key必须是唯一的，适合用来存储对象）
sort set 有序集合

redis的持久化：是指在redis将数据写入内存的同时，异步的慢慢将数据写入磁盘。（可能会丢失少量的数据）
RDB：是指在指定时间间隔执行数据集的快照。
AOF：是指会记录服务器接收的每个写入操作，这些操作会在服务器启动的时候再次执行，重建原始的数据集。记录是采用追加的方式，当日志太大时，后台会触发rewrite

redis的淘汰机制（缓存淘汰策略）：（lru）当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key
删除的方法：定期删除：在一定时间随机检查删除
                   懒惰删除：就是在用户取数据走redis的时候，会去检查这个key是否超过失效时间，失效就删除

redis的持久化，RDB，AOF
RDB：在指定的时间间隔能对你的数据进行快照存储。
AOF：记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据。
RDB是将数据写入到云磁盘中，间隔时间长，但更高效快速。可能存在问价丢失。
aof是将数据写入日志文件，间隔时间短。过程复杂，容易产生bug。
redis的缓存穿透：当大量的恶意请求发来时，就是数据请求过来，即不走redis，也不走mysql，容易造成服务器挂掉。在redis和mysql中间放一个布隆过滤器
（主要用来去重，备份一份mysql的id，知道mysql哪些是没有的，没有就直接返回）
redis的缓存击穿：大量的有效用户请求过来，redis的某一个key失效以后，直接打到数据库，造成数据库挂了。此时可以在redis和mysql中间再加一层缓存（本地缓存）
缓存雪崩，是指在某一个时间段，缓存集中过期失效。（解决方法也是加上一些中间缓存）

缓存怎么与数据库数据保持一致性？
双写：先更新数据库，在更新缓存。（脏数据）
删除缓存再更新数据库
延迟双删：删除缓存在更新数据库在删除缓存
binlog订阅删除，消息队列：

springboot整合redis
使用JedisPoolConfig（配置连接池）
1.添加依赖
2.配置连接信息（端口号）
3.在配置类中设置连接还有key，value的序列化器。（StringRedisSerializer）来创建RedisTemplate去操作redis
redisTemplate.opsForValue().set("days",d)
4.给对象实现Serializer接口，让他可序列化。



